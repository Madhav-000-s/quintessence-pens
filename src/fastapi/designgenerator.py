# -*- coding: utf-8 -*-
"""DESIGNGENERATOR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Lu8rObkY3y15iAHtYdVuzjouKfBa2NVD
"""

import numpy as np
import pandas as pd
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.cluster import KMeans
from mlxtend.frequent_patterns import apriori, association_rules
from mlxtend.preprocessing import TransactionEncoder
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import pickle
from typing import List, Dict, Optional
import warnings
import gc
from collections import Counter
warnings.filterwarnings('ignore')
import json

# Memory optimization
tf.config.threading.set_intra_op_parallelism_threads(2)
tf.config.threading.set_inter_op_parallelism_threads(2)

class SyntheticDataGenerator:
    """Generate synthetic data matching EXACT database schema."""

    @staticmethod
    def generate_materials(n=10):
        """Material table: id, name, weight, cost, created_at"""
        materials = []
        material_names = ['Gold', 'Platinum', 'Titanium', 'Stainless Steel', 'Carbon Fiber',
                         'Silver', 'Bronze', 'Aluminum', 'Resin', 'Wood']

        for i in range(n):
            materials.append({
                'id': i + 1,
                'created_at': pd.Timestamp.now(),
                'name': material_names[i],
                'weight': float(np.random.uniform(5, 30)),
                'cost': float(np.random.uniform(10, 200))
            })
        return pd.DataFrame(materials)

    @staticmethod
    def generate_designs(n=8):
        """Design table: design_id, description, font, cost, colour, hex_code"""
        designs = []
        fonts = ['Script', 'Serif', 'Sans-Serif', 'Gothic']
        colors = ['Black', 'Blue', 'Gold', 'Silver', 'Red', 'Green', 'Purple', 'Bronze']

        for i in range(n):
            designs.append({
                'design_id': i + 1,
                'description': f'Design Pattern {i+1}',
                'font': fonts[i % len(fonts)],
                'cost': float(np.random.uniform(20, 100)),
                'colour': colors[i % len(colors)],
                'hex_code': f'#{np.random.randint(0, 0xFFFFFF):06x}'
            })
        return pd.DataFrame(designs)

    @staticmethod
    def generate_coatings(n=6):
        """Coating table: coating_id, colour, hex_code, type"""
        coatings = []
        types = ['Matte', 'Glossy', 'Metallic']
        colors = ['Black', 'Silver', 'Gold', 'Blue', 'Red', 'White']

        for i in range(n):
            coatings.append({
                'coating_id': i + 1,
                'colour': colors[i % len(colors)],
                'hex_code': f'#{np.random.randint(0, 0xFFFFFF):06x}',
                'type': types[i % len(types)]
            })
        return pd.DataFrame(coatings)

    @staticmethod
    def generate_ink_configs(n=10):
        """InkConfig table: ink_type_id, type_name, description, color_name, hexcode, cost"""
        inks = []
        colors = ['Black', 'Blue', 'Royal Blue', 'Red', 'Green', 'Purple', 'Brown', 'Turquoise', 'Orange', 'Pink']

        for i in range(n):
            inks.append({
                'ink_type_id': i + 1,
                'type_name': f'Ink Type {i+1}',
                'description': f'Premium ink type {i+1}',
                'color_name': colors[i % len(colors)],
                'hexcode': f'#{np.random.randint(0, 0xFFFFFF):06x}',
                'cost': float(np.random.uniform(5, 30))
            })
        return pd.DataFrame(inks)

    @staticmethod
    def generate_nib_configs(n=12):
        """NibConfig table: nibtype_id, description, size, material_id, design_id, cost"""
        nibs = []
        sizes = ['Extra Fine', 'Fine', 'Medium', 'Broad', 'Stub']

        for i in range(n):
            nibs.append({
                'nibtype_id': i + 1,
                'description': f'Nib Type {i+1}',
                'size': sizes[i % len(sizes)],
                'material_id': (i % 10) + 1,
                'design_id': (i % 8) + 1,
                'cost': float(np.random.uniform(30, 150))
            })
        return pd.DataFrame(nibs)

    @staticmethod
    def generate_barrel_configs(n=15):
        """BarrelConfig table: barrel_id, design_id, engraving_id, grip_type, coating_id, cost, shape, description, material_id"""
        barrels = []
        shapes = ['Cylindrical', 'Tapered', 'Curved', 'Hexagonal', 'Octagonal']
        grip_types = ['Smooth', 'Textured', 'Grooved']

        for i in range(n):
            barrels.append({
                'barrel_id': i + 1,
                'design_id': (i % 8) + 1,
                'engraving_id': (i % 12) + 1,
                'grip_type': grip_types[i % len(grip_types)],
                'coating_id': (i % 6) + 1,
                'cost': float(np.random.uniform(50, 200)),
                'shape': shapes[i % len(shapes)],
                'description': f'Barrel Design {i+1}',
                'material_id': (i % 10) + 1
            })
        return pd.DataFrame(barrels)

    @staticmethod
    def generate_cap_configs(n=12):
        """CapConfig table: cap_type_id, description, material_id, design_id, engraving_id, clip_design_id, coating_id, cost"""
        caps = []

        for i in range(n):
            caps.append({
                'cap_type_id': i + 1,
                'description': f'Cap Type {i+1}',
                'material_id': (i % 10) + 1,
                'design_id': (i % 8) + 1,
                'engraving_id': (i % 12) + 1,
                'clip_design_id': (i % 8) + 1,
                'coating_id': (i % 6) + 1,
                'cost': float(np.random.uniform(30, 120))
            })
        return pd.DataFrame(caps)

    @staticmethod
    def generate_engravings(n=12):
        """Engravings table: engraving_id, font, type_name, description, material_id, cost"""
        engravings = []
        fonts = ['Script', 'Block', 'Cursive', 'Gothic', 'Modern']
        types = ['Laser', 'Hand', 'Machine', 'Chemical']

        for i in range(n):
            engravings.append({
                'engraving_id': i + 1,
                'font': fonts[i % len(fonts)],
                'type_name': types[i % len(types)],
                'description': f'Engraving Style {i+1}',
                'material_id': (i % 10) + 1,
                'cost': float(np.random.uniform(10, 80))
            })
        return pd.DataFrame(engravings)

    @staticmethod
    def generate_pens(n=50):
        """Pen table: pen_id, pentype, nibtype_id, ink_type_id, cap_type_id, barrel_id, cost"""
        pens = []
        pen_types = ['Fountain', 'Rollerball', 'Ballpoint']

        for i in range(n):
            pens.append({
                'pen_id': i + 1,
                'pentype': pen_types[i % len(pen_types)],
                'nibtype_id': (i % 12) + 1,
                'ink_type_id': (i % 10) + 1,
                'cap_type_id': (i % 12) + 1,
                'barrel_id': (i % 15) + 1,
                'cost': float(np.random.uniform(100, 500))
            })
        return pd.DataFrame(pens)

    @staticmethod
    def generate_user_interactions(n_users=500, n_pens=50):
        """UserPenInteractions table: user_id, pen_id, rating"""
        interactions = []

        for user_id in range(1, n_users + 1):
            n_interactions = np.random.randint(3, 12)
            pen_ids = np.random.choice(n_pens, n_interactions, replace=False) + 1

            for pen_id in pen_ids:
                interactions.append({
                    'user_id': user_id,
                    'pen_id': int(pen_id),
                    'rating': float(np.random.uniform(3, 5))
                })

        return pd.DataFrame(interactions)

class DesignSyntheticDataGenerator:
    """Generate synthetic data based on user likes/preferences."""

    @staticmethod
    def generate_user_liked_pens(n_users=500, pens_df=None,
                                 ink_df=None, barrel_df=None, cap_df=None,
                                 nib_df=None, engraving_df=None):
        """
        Generate user likes for existing pens.
        Schema: user_id, pen_id, liked (boolean), rating
        """
        if pens_df is None:
            return pd.DataFrame()

        likes = []

        # User personas with specific preferences
        personas = {
            'color_lover_blue': {
                'weight': 0.2,
                'prefers': {'ink_colors': ['Blue', 'Royal Blue'], 'rating_avg': 4.5}
            },
            'color_lover_red': {
                'weight': 0.15,
                'prefers': {'ink_colors': ['Red', 'Orange'], 'rating_avg': 4.3}
            },
            'material_gold': {
                'weight': 0.2,
                'prefers': {'materials': [1, 2, 6], 'rating_avg': 4.6}  # Gold materials
            },
            'engraving_script': {
                'weight': 0.15,
                'prefers': {'engraving_fonts': ['Script', 'Cursive'], 'rating_avg': 4.4}
            },
            'shape_curved': {
                'weight': 0.15,
                'prefers': {'barrel_shapes': ['Curved', 'Tapered'], 'rating_avg': 4.2}
            },
            'nib_fine': {
                'weight': 0.15,
                'prefers': {'nib_sizes': ['Fine', 'Extra Fine'], 'rating_avg': 4.5}
            }
        }

        # Assign personas
        persona_list = []
        for persona, attrs in personas.items():
            count = int(n_users * attrs['weight'])
            persona_list.extend([persona] * count)
        while len(persona_list) < n_users:
            persona_list.append(np.random.choice(list(personas.keys())))

        np.random.shuffle(persona_list)

        # Create enhanced pen lookup
        pen_lookup = pens_df.copy()
        if ink_df is not None:
            pen_lookup = pen_lookup.merge(ink_df[['ink_type_id', 'color_name']],
                                         on='ink_type_id', how='left')
        if barrel_df is not None:
            pen_lookup = pen_lookup.merge(barrel_df[['barrel_id', 'shape', 'material_id']],
                                         on='barrel_id', how='left')
        if nib_df is not None:
            pen_lookup = pen_lookup.merge(nib_df[['nibtype_id', 'size']],
                                         on='nibtype_id', how='left')

        for user_id in range(1, n_users + 1):
            persona = persona_list[user_id - 1]
            persona_attrs = personas[persona]
            n_likes = np.random.randint(5, 20)

            # Select pens matching persona preferences
            candidate_pens = pen_lookup.copy()

            if 'ink_colors' in persona_attrs['prefers']:
                preferred_colors = persona_attrs['prefers']['ink_colors']
                matching_pens = candidate_pens[candidate_pens['color_name'].isin(preferred_colors)]
                if len(matching_pens) > 0:
                    candidate_pens = matching_pens

            if 'barrel_shapes' in persona_attrs['prefers']:
                preferred_shapes = persona_attrs['prefers']['barrel_shapes']
                matching_pens = candidate_pens[candidate_pens['shape'].isin(preferred_shapes)]
                if len(matching_pens) > 0:
                    candidate_pens = matching_pens

            if 'nib_sizes' in persona_attrs['prefers']:
                preferred_sizes = persona_attrs['prefers']['nib_sizes']
                matching_pens = candidate_pens[candidate_pens['size'].isin(preferred_sizes)]
                if len(matching_pens) > 0:
                    candidate_pens = matching_pens

            # Sample pens
            n_available = min(n_likes, len(candidate_pens))
            if n_available > 0:
                selected_pens = candidate_pens.sample(n_available)

                for _, pen in selected_pens.iterrows():
                    rating = np.clip(
                        persona_attrs['prefers']['rating_avg'] + np.random.normal(0, 0.5),
                        1, 5
                    )

                    likes.append({
                        'user_id': user_id,
                        'pen_id': int(pen['pen_id']),
                        'liked': True,
                        'rating': float(round(rating, 1))
                    })

        return pd.DataFrame(likes)


class CustomPenDesignSuggestionSystem:
    """
    Smart design system that learns from user's liked pens.
    Generates COMPLETE pen configurations for frontend display.
    """

    def __init__(self):
        self.component_encoders = {}
        self.scaler = StandardScaler()
        self.component_predictor = None
        self.kmeans = None
        self.component_features = {}
        self.pen_data = None
        self.user_preferences_cache = {}

    def prepare_component_features(self,
                                   pens_df: pd.DataFrame,
                                   ink_config_df: pd.DataFrame,
                                   barrel_config_df: pd.DataFrame,
                                   cap_config_df: pd.DataFrame,
                                   nib_config_df: pd.DataFrame,
                                   engraving_config_df: pd.DataFrame,
                                   material_df: pd.DataFrame,
                                   design_df: pd.DataFrame,
                                   coating_df: pd.DataFrame) -> Dict[str, pd.DataFrame]:
        """Store ALL component data with complete table information."""

        self.component_features = {
            'ink': ink_config_df.copy(),
            'barrel': barrel_config_df.copy(),
            'cap': cap_config_df.copy(),
            'nib': nib_config_df.copy(),
            'engraving': engraving_config_df.copy(),
            'material': material_df.copy(),
            'design': design_df.copy(),
            'coating': coating_df.copy()
        }

        # Store complete pen data with all component details
        self.pen_data = pens_df.copy()

        return self.component_features

    def extract_user_preferences(self, user_id: int,
                                 user_likes_df: pd.DataFrame,
                                 pens_df: pd.DataFrame) -> Dict:
        """
        Analyze user's liked pens to extract preferences.
        Learns patterns like: "User likes red barrels" or "User prefers Script engravings"
        """
        user_likes = user_likes_df[
            (user_likes_df['user_id'] == user_id) &
            (user_likes_df['liked'] == True)
        ]

        if len(user_likes) == 0:
            return None

        # Get full pen details for liked pens
        liked_pen_ids = user_likes['pen_id'].tolist()
        liked_pens = pens_df[pens_df['pen_id'].isin(liked_pen_ids)]

        preferences = {
            'user_id': user_id,
            'n_liked_pens': len(liked_pens),
            'avg_rating': user_likes['rating'].mean(),

            # Pen type preference
            'preferred_pentype': liked_pens['pentype'].mode()[0] if len(liked_pens) > 0 else None,
            'pentype_counts': liked_pens['pentype'].value_counts().to_dict(),

            # Component preferences
            'preferred_ink_ids': liked_pens['ink_type_id'].value_counts().to_dict(),
            'most_liked_ink_id': liked_pens['ink_type_id'].mode()[0] if len(liked_pens) > 0 else None,

            'preferred_barrel_ids': liked_pens['barrel_id'].value_counts().to_dict(),
            'most_liked_barrel_id': liked_pens['barrel_id'].mode()[0] if len(liked_pens) > 0 else None,

            'preferred_cap_ids': liked_pens['cap_type_id'].value_counts().to_dict(),
            'most_liked_cap_id': liked_pens['cap_type_id'].mode()[0] if len(liked_pens) > 0 else None,

            'preferred_nib_ids': liked_pens['nibtype_id'].value_counts().to_dict(),
            'most_liked_nib_id': liked_pens['nibtype_id'].mode()[0] if len(liked_pens) > 0 else None,
        }

        # Analyze deeper patterns from component tables
        preferences.update(self._analyze_component_patterns(liked_pens))

        return preferences

    def _analyze_component_patterns(self, liked_pens: pd.DataFrame) -> Dict:
        """Analyze patterns in component attributes (colors, materials, shapes, etc.)"""
        patterns = {}

        # Ink color patterns
        ink_ids = liked_pens['ink_type_id'].tolist()
        ink_details = self.component_features['ink'][
            self.component_features['ink']['ink_type_id'].isin(ink_ids)]

        if len(ink_details) > 0:
            patterns['preferred_ink_colors'] = ink_details['color_name'].value_counts().to_dict()
            patterns['most_liked_ink_color'] = ink_details['color_name'].mode()[0]

        # Barrel patterns (shape, material, grip)
        barrel_ids = liked_pens['barrel_id'].tolist()
        barrel_details = self.component_features['barrel'][
            self.component_features['barrel']['barrel_id'].isin(barrel_ids)]

        if len(barrel_details) > 0:
            patterns['preferred_barrel_shapes'] = barrel_details['shape'].value_counts().to_dict()
            patterns['preferred_barrel_materials'] = barrel_details['material_id'].value_counts().to_dict()
            patterns['preferred_grip_types'] = barrel_details['grip_type'].value_counts().to_dict()

        # Nib patterns (size)
        nib_ids = liked_pens['nibtype_id'].tolist()
        nib_details = self.component_features['nib'][
            self.component_features['nib']['nibtype_id'].isin(nib_ids)]

        if len(nib_details) > 0:
            patterns['preferred_nib_sizes'] = nib_details['size'].value_counts().to_dict()
            patterns['most_liked_nib_size'] = nib_details['size'].mode()[0]

        # Engraving patterns (font, type)
        if 'barrel_engraving_id' in barrel_details.columns:
            engraving_ids = barrel_details['engraving_id'].dropna().astype(int).tolist()
            engraving_details = self.component_features['engraving'][
                self.component_features['engraving']['engraving_id'].isin(engraving_ids)]

            if len(engraving_details) > 0:
                patterns['preferred_engraving_fonts'] = engraving_details['font'].value_counts().to_dict()
                patterns['preferred_engraving_types'] = engraving_details['type_name'].value_counts().to_dict()

        return patterns

    def build_component_predictor(self, n_features: int,
                                 n_ink: int, n_barrel: int, n_cap: int,
                                 n_nib: int, n_engraving: int, n_pentype: int):
        """Build neural network that predicts ALL components."""

        user_input = layers.Input(shape=(n_features,), name='user_features')

        x = layers.Dense(64, activation='relu')(user_input)
        x = layers.BatchNormalization()(x)
        x = layers.Dropout(0.2)(x)
        shared = layers.Dense(32, activation='relu')(x)

        # Pen type prediction
        pentype_branch = layers.Dense(16, activation='relu')(shared)
        pentype_output = layers.Dense(n_pentype, activation='softmax', name='pentype_output')(pentype_branch)

        # Component predictions
        ink_branch = layers.Dense(16, activation='relu')(shared)
        ink_output = layers.Dense(n_ink, activation='softmax', name='ink_output')(ink_branch)

        barrel_branch = layers.Dense(16, activation='relu')(shared)
        barrel_output = layers.Dense(n_barrel, activation='softmax', name='barrel_output')(barrel_branch)

        cap_branch = layers.Dense(16, activation='relu')(shared)
        cap_output = layers.Dense(n_cap, activation='softmax', name='cap_output')(cap_branch)

        nib_branch = layers.Dense(16, activation='relu')(shared)
        nib_output = layers.Dense(n_nib, activation='softmax', name='nib_output')(nib_branch)

        engraving_branch = layers.Dense(16, activation='relu')(shared)
        engraving_output = layers.Dense(n_engraving, activation='softmax', name='engraving_output')(engraving_branch)

        model = keras.Model(
            inputs=user_input,
            outputs=[pentype_output, ink_output, barrel_output, cap_output, nib_output, engraving_output]
        )

        model.compile(
            optimizer=keras.optimizers.Adam(learning_rate=0.001),
            loss='sparse_categorical_crossentropy',
            metrics=['accuracy', 'accuracy', 'accuracy', 'accuracy', 'accuracy', 'accuracy']
        )

        return model

    def train_design_system(self, user_likes_df: pd.DataFrame,
                           pens_df: pd.DataFrame, epochs: int = 20):
        """Train system on user likes to learn preferences."""

        # Prepare training data from user likes
        training_data = []

        for user_id in user_likes_df['user_id'].unique():
            prefs = self.extract_user_preferences(user_id, user_likes_df, pens_df)
            if prefs is None:
                continue

            # Get liked pens for this user
            user_likes = user_likes_df[
                (user_likes_df['user_id'] == user_id) &
                (user_likes_df['liked'] == True)
            ]

            liked_pens = pens_df[pens_df['pen_id'].isin(user_likes['pen_id'])]

            for _, pen in liked_pens.iterrows():
                training_data.append({
                    'user_id': user_id,
                    'n_likes': prefs['n_liked_pens'],
                    'avg_rating': prefs['avg_rating'],
                    'pentype': pen['pentype'],
                    'ink_type_id': pen['ink_type_id'],
                    'barrel_id': pen['barrel_id'],
                    'cap_type_id': pen['cap_type_id'],
                    'nibtype_id': pen['nibtype_id'],
                    'engraving_id': np.random.randint(1, 13)  # Placeholder
                })

        training_df = pd.DataFrame(training_data)

        # Encode components
        self.component_encoders['pentype'] = LabelEncoder()
        self.component_encoders['ink'] = LabelEncoder()
        self.component_encoders['barrel'] = LabelEncoder()
        self.component_encoders['cap'] = LabelEncoder()
        self.component_encoders['nib'] = LabelEncoder()
        self.component_encoders['engraving'] = LabelEncoder()

        training_df['pentype_encoded'] = self.component_encoders['pentype'].fit_transform(training_df['pentype'])
        training_df['ink_encoded'] = self.component_encoders['ink'].fit_transform(training_df['ink_type_id'])
        training_df['barrel_encoded'] = self.component_encoders['barrel'].fit_transform(training_df['barrel_id'])
        training_df['cap_encoded'] = self.component_encoders['cap'].fit_transform(training_df['cap_type_id'])
        training_df['nib_encoded'] = self.component_encoders['nib'].fit_transform(training_df['nibtype_id'])
        training_df['engraving_encoded'] = self.component_encoders['engraving'].fit_transform(training_df['engraving_id'])

        # Prepare features
        X = training_df[['n_likes', 'avg_rating']].values
        X_scaled = self.scaler.fit_transform(X)

        y_pentype = training_df['pentype_encoded'].values
        y_ink = training_df['ink_encoded'].values
        y_barrel = training_df['barrel_encoded'].values
        y_cap = training_df['cap_encoded'].values
        y_nib = training_df['nib_encoded'].values
        y_engraving = training_df['engraving_encoded'].values

        # Build model
        self.component_predictor = self.build_component_predictor(
            n_features=X_scaled.shape[1],
            n_ink=len(self.component_encoders['ink'].classes_),
            n_barrel=len(self.component_encoders['barrel'].classes_),
            n_cap=len(self.component_encoders['cap'].classes_),
            n_nib=len(self.component_encoders['nib'].classes_),
            n_engraving=len(self.component_encoders['engraving'].classes_),
            n_pentype=len(self.component_encoders['pentype'].classes_)
        )

        # Train
        history = self.component_predictor.fit(
            X_scaled,
            [y_pentype, y_ink, y_barrel, y_cap, y_nib, y_engraving],
            epochs=epochs,
            batch_size=128,
            validation_split=0.15,
            verbose=0
        )

        return history

    def suggest_custom_design(self, user_id: int,
                             user_likes_df: pd.DataFrame,
                             pens_df: pd.DataFrame) -> Dict:
        """
        Generate COMPLETE pen design based on user's liked pens.
        Returns everything needed for frontend display.
        """

        # Extract user preferences from liked pens
        prefs = self.extract_user_preferences(user_id, user_likes_df, pens_df)

        if prefs is None:
            # New user - use defaults
            n_likes = 0
            avg_rating = 4.0
        else:
            n_likes = prefs['n_liked_pens']
            avg_rating = prefs['avg_rating']

        # Predict using neural network
        user_input = np.array([[n_likes, avg_rating]])
        user_input_scaled = self.scaler.transform(user_input)

        predictions = self.component_predictor.predict(user_input_scaled, verbose=0)

        # Get predicted IDs
        pentype_encoded = np.argmax(predictions[0][0])
        ink_encoded = np.argmax(predictions[1][0])
        barrel_encoded = np.argmax(predictions[2][0])
        cap_encoded = np.argmax(predictions[3][0])
        nib_encoded = np.argmax(predictions[4][0])
        engraving_encoded = np.argmax(predictions[5][0])

        # Decode to original IDs
        pentype = self.component_encoders['pentype'].inverse_transform([pentype_encoded])[0]
        ink_id = self.component_encoders['ink'].inverse_transform([ink_encoded])[0]
        barrel_id = self.component_encoders['barrel'].inverse_transform([barrel_encoded])[0]
        cap_id = self.component_encoders['cap'].inverse_transform([cap_encoded])[0]
        nib_id = self.component_encoders['nib'].inverse_transform([nib_encoded])[0]
        engraving_id = self.component_encoders['engraving'].inverse_transform([engraving_encoded])[0]

        # If user has preferences, use preference-based selection
        if prefs and 'most_liked_ink_id' in prefs:
            ink_id = prefs['most_liked_ink_id']
        if prefs and 'most_liked_barrel_id' in prefs:
            barrel_id = prefs['most_liked_barrel_id']
        if prefs and 'most_liked_cap_id' in prefs:
            cap_id = prefs['most_liked_cap_id']
        if prefs and 'most_liked_nib_id' in prefs:
            nib_id = prefs['most_liked_nib_id']

        # Get COMPLETE component details
        ink_details = self.component_features['ink'][
            self.component_features['ink']['ink_type_id'] == ink_id].iloc[0].to_dict()

        barrel_details = self.component_features['barrel'][
            self.component_features['barrel']['barrel_id'] == barrel_id].iloc[0].to_dict()

        cap_details = self.component_features['cap'][
            self.component_features['cap']['cap_type_id'] == cap_id].iloc[0].to_dict()

        nib_details = self.component_features['nib'][
            self.component_features['nib']['nibtype_id'] == nib_id].iloc[0].to_dict()

        engraving_details = self.component_features['engraving'][
            self.component_features['engraving']['engraving_id'] == engraving_id].iloc[0].to_dict()

        # Get related details (materials, designs, coatings)
        barrel_material = self.component_features['material'][
            self.component_features['material']['id'] == barrel_details['material_id']
        ].iloc[0].to_dict() if 'material_id' in barrel_details else {}

        barrel_design = self.component_features['design'][
            self.component_features['design']['design_id'] == barrel_details['design_id']
        ].iloc[0].to_dict() if 'design_id' in barrel_details else {}

        barrel_coating = self.component_features['coating'][
            self.component_features['coating']['coating_id'] == barrel_details['coating_id']
        ].iloc[0].to_dict() if 'coating_id' in barrel_details else {}

        cap_material = self.component_features['material'][
            self.component_features['material']['id'] == cap_details['material_id']
        ].iloc[0].to_dict() if 'material_id' in cap_details else {}

        nib_material = self.component_features['material'][
            self.component_features['material']['id'] == nib_details['material_id']
        ].iloc[0].to_dict() if 'material_id' in nib_details else {}

        # Calculate total cost
        total_cost = (
            float(ink_details['cost']) +
            float(barrel_details['cost']) +
            float(cap_details['cost']) +
            float(nib_details['cost']) +
            float(engraving_details['cost'])
        )

        # Confidence scores
        confidence_scores = {
            'pentype': float(predictions[0][0][pentype_encoded]),
            'ink': float(predictions[1][0][ink_encoded]),
            'barrel': float(predictions[2][0][barrel_encoded]),
            'cap': float(predictions[3][0][cap_encoded]),
            'nib': float(predictions[4][0][nib_encoded]),
            'engraving': float(predictions[5][0][engraving_encoded])
        }

        # Return COMPLETE pen design for frontend
        return {
            'pen': {
                'pentype': pentype,
                'total_cost': total_cost
            },
            'ink': {
                **ink_details,
                'hexcode_display': ink_details['hexcode']
            },
            'barrel': {
                **barrel_details,
                'material': barrel_material,
                'design': barrel_design,
                'coating': barrel_coating
            },
            'cap': {
                **cap_details,
                'material': cap_material
            },
            'nib': {
                **nib_details,
                'material': nib_material
            },
            'engraving': engraving_details,
            'confidence_scores': confidence_scores,
            'user_preferences': prefs,
            'why_suggested': self._generate_explanation(prefs)
        }

    def _generate_explanation(self, prefs: Optional[Dict]) -> str:
        """Generate human-readable explanation of why this design was suggested."""
        if prefs is None:
            return "Based on popular choices for new users"

        explanations = []

        if 'most_liked_ink_color' in prefs:
            explanations.append(f"You often like {prefs['most_liked_ink_color']} ink")

        if 'preferred_barrel_shapes' in prefs:
            top_shape = max(prefs['preferred_barrel_shapes'],
                          key=prefs['preferred_barrel_shapes'].get)
            explanations.append(f"You prefer {top_shape} barrel shapes")

        if 'most_liked_nib_size' in prefs:
            explanations.append(f"You typically choose {prefs['most_liked_nib_size']} nibs")

        if 'preferred_engraving_fonts' in prefs:
            top_font = max(prefs['preferred_engraving_fonts'],
                         key=prefs['preferred_engraving_fonts'].get)
            explanations.append(f"You favor {top_font} engraving style")

        return " • ".join(explanations) if explanations else "Based on your overall preferences"

    def save_model(self, filepath='design_suggester'):
        """Save model."""
        if self.component_predictor:
            self.component_predictor.save(f"{filepath}.keras", save_format='keras')

        metadata = {
            'component_encoders': self.component_encoders,
            'scaler': self.scaler,
            'component_features': {k: v.to_dict('records')
                                  for k, v in self.component_features.items()},
            'pen_data': self.pen_data.to_dict('records') if self.pen_data is not None else []
        }

        with open(f"{filepath}_meta.pkl", 'wb') as f:
            pickle.dump(metadata, f, protocol=4)

    def load_model(self, filepath='design_suggester'):
        """Load model."""
        self.component_predictor = keras.models.load_model(f"{filepath}.keras")

        with open(f"{filepath}_meta.pkl", 'rb') as f:
            metadata = pickle.load(f)
            self.component_encoders = metadata['component_encoders']
            self.scaler = metadata['scaler']
            self.component_features = {k: pd.DataFrame(v)
                                      for k, v in metadata['component_features'].items()}
            self.pen_data = pd.DataFrame(metadata['pen_data'])

def train_and_save_design_suggester(model_basename: str = 'design_suggester') -> None:
    """Utility to generate data, train the suggester model, and persist it.

    This mirrors the __main__ training flow but is importable so other modules
    (e.g., the FastAPI backend) can call it during initialization if model
    artifacts are missing.
    """
    gen = SyntheticDataGenerator()

    materials_df = gen.generate_materials(10)
    designs_df = gen.generate_designs(8)
    coatings_df = gen.generate_coatings(6)
    ink_configs_df = gen.generate_ink_configs(10)
    nib_configs_df = gen.generate_nib_configs(12)
    barrel_configs_df = gen.generate_barrel_configs(15)
    cap_configs_df = gen.generate_cap_configs(12)
    engravings_df = gen.generate_engravings(12)
    pens_df = gen.generate_pens(50)

    design_gen = DesignSyntheticDataGenerator()
    user_likes_df = design_gen.generate_user_liked_pens(
        n_users=500,
        pens_df=pens_df,
        ink_df=ink_configs_df,
        barrel_df=barrel_configs_df,
        nib_df=nib_configs_df
    )

    suggester = CustomPenDesignSuggestionSystem()
    suggester.prepare_component_features(
        pens_df, ink_configs_df, barrel_configs_df, cap_configs_df,
        nib_configs_df, engravings_df, materials_df, designs_df, coatings_df
    )

    suggester.train_design_system(user_likes_df, pens_df, epochs=20)
    suggester.save_model(model_basename)

# Main execution
if __name__ == "__main__":
    print("="*80)
    print("SMART CUSTOM DESIGN SYSTEM - LEARNS FROM USER LIKES")
    print("="*80)

    # Import from recommendation system
    import sys
    sys.path.append('.')

    print("\n1. Generating component data...")
    gen = SyntheticDataGenerator()

    materials_df = gen.generate_materials(10)
    designs_df = gen.generate_designs(8)
    coatings_df = gen.generate_coatings(6)
    ink_configs_df = gen.generate_ink_configs(10)
    nib_configs_df = gen.generate_nib_configs(12)
    barrel_configs_df = gen.generate_barrel_configs(15)
    cap_configs_df = gen.generate_cap_configs(12)
    engravings_df = gen.generate_engravings(12)
    pens_df = gen.generate_pens(50)

    print(f"   ✓ Generated all tables")

    # Generate user likes
    print("\n2. Generating user likes...")
    design_gen = DesignSyntheticDataGenerator()
    user_likes_df = design_gen.generate_user_liked_pens(
        n_users=500,
        pens_df=pens_df,
        ink_df=ink_configs_df,
        barrel_df=barrel_configs_df,
        nib_df=nib_configs_df
    )

    print(f"   ✓ Generated {len(user_likes_df)} user likes from 500 users")

    # Train system
    print("\n3. Training design system...")
    suggester = CustomPenDesignSuggestionSystem()

    suggester.prepare_component_features(
        pens_df, ink_configs_df, barrel_configs_df, cap_configs_df,
        nib_configs_df, engravings_df, materials_df, designs_df, coatings_df
    )

    history = suggester.train_design_system(user_likes_df, pens_df, epochs=20)
    print(f"   ✓ Model trained")

    # Save
    suggester.save_model('design_suggester')
    print("   ✓ Model saved")

    # Test cases
    print("\n" + "="*80)
    print("TESTING: 10 PERSONALIZED DESIGN SUGGESTIONS")
    print("="*80)

    test_users = np.random.choice(user_likes_df['user_id'].unique(), 10, replace=False)

    for idx, user_id in enumerate(test_users, 1):
        print(f"\n{'-'*80}")
        print(f"User {idx}: ID {user_id}")
        print(f"{'-'*80}")

        # Get user's liked pens for context
        user_likes = user_likes_df[user_likes_df['user_id'] == user_id]
        n_liked = len(user_likes[user_likes['liked'] == True])
        avg_rating = user_likes[user_likes['liked'] == True]['rating'].mean()

        print(f"Profile: Liked {n_liked} pens | Avg rating: {avg_rating:.2f}")

        # Generate suggestion
        design = suggester.suggest_custom_design(user_id, user_likes_df, pens_df)

        # Display suggestion
        print(f"\n✓ SUGGESTED DESIGN:")
        print(f"  Pen Type: {design['pen']['pentype']}")
        print(f"  Total Cost: ${design['pen']['total_cost']:.2f}")

        print(f"\n  INK:")
        print(f"    Type: {design['ink'].get('type_name', 'N/A')}")
        print(f"    Color: {design['ink'].get('color_name', 'N/A')}")
        print(f"    Hex: {design['ink'].get('hexcode_display', 'N/A')}")
        print(f"    Cost: ${design['ink'].get('cost', 0):.2f}")

        print(f"\n  BARREL:")
        print(f"    Shape: {design['barrel'].get('shape', 'N/A')}")
        print(f"    Grip: {design['barrel'].get('grip_type', 'N/A')}")
        print(f"    Description: {design['barrel'].get('description', 'N/A')}")
        print(f"    Cost: ${design['barrel'].get('cost', 0):.2f}")

        if design['barrel'].get('material'):
            print(f"    Material: {design['barrel']['material'].get('name', 'N/A')} "
                  f"(${design['barrel']['material'].get('cost', 0):.2f})")

        print(f"\n  CAP:")
        print(f"    Description: {design['cap'].get('description', 'N/A')}")
        print(f"    Cost: ${design['cap'].get('cost', 0):.2f}")

        if design['cap'].get('material'):
            print(f"    Material: {design['cap']['material'].get('name', 'N/A')}")

        print(f"\n  NIB:")
        print(f"    Size: {design['nib'].get('size', 'N/A')}")
        print(f"    Description: {design['nib'].get('description', 'N/A')}")
        print(f"    Cost: ${design['nib'].get('cost', 0):.2f}")

        if design['nib'].get('material'):
            print(f"    Material: {design['nib']['material'].get('name', 'N/A')}")

        print(f"\n  ENGRAVING:")
        print(f"    Font: {design['engraving'].get('font', 'N/A')}")
        print(f"    Type: {design['engraving'].get('type_name', 'N/A')}")
        print(f"    Cost: ${design['engraving'].get('cost', 0):.2f}")

        print(f"\n  CONFIDENCE SCORES:")
        for component, score in design['confidence_scores'].items():
            confidence_pct = score * 100
            print(f"    {component.capitalize()}: {confidence_pct:.1f}%")

        print(f"\n  WHY SUGGESTED:")
        print(f"    {design['why_suggested']}")

        # Memory cleanup
        gc.collect()

    print("\n" + "="*80)
    print("✓ ALL TESTS COMPLETED SUCCESSFULLY")
    print("="*80)

